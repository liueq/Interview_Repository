# 线程阻塞的原因

**一般线程中的阻塞：**

A、线程执行了Thread.sleep(int millsecond);方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行

B、线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行。

C、线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法。

D、线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态。

**Socket客户端的阻塞：**

A、请求与服务器连接时，调用connect方法，进入阻塞状态，直至连接成功。

B、当从Socket输入流读取数据时，在读取足够的数据之前会进入阻塞状态。比如说通过BufferedReader类使用readLine()方法时，在没有读出一行数据之前，数据量就不算是足够，会处在阻塞状态下。

C、调用Socket的setSoLinger()方法关闭了Socket延迟，当执行Socket的close方法时，会进入阻塞状态，知道底层Socket发送完所有的剩余数据

**Socket服务器的阻塞：**

A、线程执行ServerSocket的accept()方法，等待客户的连接，知道接收到客户的连接，才从accept方法中返回一个Socket对象

B、从Socket输入流读取数据时，如果输入流没有足够的数据，就会进入阻塞状态

C、线程向Socket的输出流写入一批数据，可能进入阻塞状态


当程序阻塞时，会降低程序的效率，于是人们就希望能引入非阻塞的操作方法。    

所谓非阻塞方法，就是指当线程执行这些方法时，如果操作还没有就绪，就立即返回，不会阻塞着等待操作就绪。Java.nio 提供了这些支持非阻塞通信的类。