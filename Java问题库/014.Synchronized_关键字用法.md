# Synchronized 关键字用法

> 未查找资料时，自己能够立即想到的内容如下

```
两种用途，一是修饰方法，二是修饰代码块。

当修饰方法的时候，进入该方法时会获取锁，退出时释放锁。所获取锁的类型，如果是静态方法，那么锁是class，如果是非静态方法，锁是对象锁。未获取锁想要访问该方法时，会阻塞直到能够获取锁为止。修饰方法的时候，锁的粒度相对较大，容易造成资源浪费。

当修饰代码块的时候，需要显示指定一个对象锁，进入该代码块需要获得该锁。注意可以使用 this，.class 等。相较于修饰方法，更节省资源。

在某个版本之前，synchronized 比起 ReentraientLock 更耗资源，但是在某个版本之后（记不清哪个了）。synchronized 经过改善，现在除非确实需要用 ReentraintLock 来划分更细的粒度，否则不在推荐使用 ReentraintLock 替代 synchronized。
```

> 经过修正后

```
两种用途，一是修饰方法，二是修饰代码块。

当修饰方法的时候，进入该方法时会自动获取锁，退出或跑出异常时自动释放锁。所获取锁的类型，如果是静态方法，那么锁是class，如果是非静态方法，锁是对象锁。未获取锁想要访问该方法时，会阻塞直到能够获取锁为止。修饰方法的时候，锁的粒度相对较大，容易造成资源浪费。

当修饰代码块的时候，需要显示指定一个对象锁，进入该代码块需要获得该锁。注意可以使用 this，.class 等。相较于修饰方法，更节省资源。

JVM 可以优化 synchronized，将两个相邻的使用相同锁的 synchronzied 可以合并为一个，实现锁的粗化，减少释放，获取锁的次数，提升性能。

synchronized 是虚拟机层面实现的，而 ReentrantLock 是JDK 实现。

在JDK 1.6之前，synchronized 比起 ReentrantLock 更耗资源，但是在JDK1.6之后通过使用偏向锁，CAS等两者性能差不多。synchronized 经过改善，现在除非确实需要用 ReentrantLock 来划分更细的粒度，否则不在推荐使用 ReentrantLock 替代 synchronized。

synchronized 范围的的变量对其他线程来说是可见的。
由于JVM 的优化，即使不使用 synchronized，只要cpu有空闲时间，就会同步主存和线程的工作内存的变量值。
（线程对于变量的读写都是在自己的工作内存中，而线程之间的通信则是通过同步自己的工作内存和主存实现的。
```